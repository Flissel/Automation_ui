"""
Action Executor - Executes PyAutoGUI actions from LLM-generated subtasks.

This module takes subtasks generated by TaskDecomposer.decompose_with_actions()
and executes them using PyAutoGUI for real desktop automation.

Usage:
    from core.action_executor import ActionExecutor
    from core.task_decomposer import TaskDecomposer

    decomposer = TaskDecomposer()
    executor = ActionExecutor()

    subtasks = await decomposer.decompose_with_actions("Open Notepad and type Hello")
    success = await executor.execute_subtasks(subtasks)
"""

import asyncio
import logging
from typing import Any, Dict, List, Optional

import pyautogui

# Safety settings
pyautogui.FAILSAFE = True  # Move mouse to corner to abort
pyautogui.PAUSE = 0.1  # Small pause between actions

logger = logging.getLogger(__name__)


class ActionExecutor:
    """Executes PyAutoGUI actions generated by TaskDecomposer."""

    def __init__(self, dry_run: bool = False):
        """
        Initialize the ActionExecutor.

        Args:
            dry_run: If True, only print actions without executing
        """
        self.dry_run = dry_run
        self._action_handlers = {
            "hotkey": self._execute_hotkey,
            "write": self._execute_write,
            "press": self._execute_press,
            "click": self._execute_click,
            "sleep": self._execute_sleep,
            "select_text": self._execute_select_text,
            "moveTo": self._execute_move_to,
            "scroll": self._execute_scroll,
        }

    async def execute_action(self, action: Dict[str, Any]) -> bool:
        """
        Execute a single PyAutoGUI action.

        Args:
            action: Dictionary with action details
                - type: Action type (hotkey, write, press, click, etc.)
                - Additional parameters based on action type

        Returns:
            True if action executed successfully
        """
        if not action:
            logger.warning("Empty action received, skipping")
            return True

        action_type = action.get("type")
        if not action_type:
            logger.warning(f"Action missing type: {action}")
            return False

        handler = self._action_handlers.get(action_type)
        if not handler:
            logger.warning(f"Unknown action type: {action_type}")
            return False

        try:
            if self.dry_run:
                logger.info(f"[DRY RUN] Would execute: {action}")
                return True

            return await handler(action)
        except pyautogui.FailSafeException:
            logger.error("FAIL-SAFE triggered! Mouse moved to corner.")
            raise
        except Exception as e:
            logger.error(f"Error executing action {action_type}: {e}")
            return False

    async def _execute_hotkey(self, action: Dict[str, Any]) -> bool:
        """Execute a keyboard hotkey combination."""
        keys = action.get("keys", [])
        if not keys:
            logger.warning("Hotkey action missing keys")
            return False

        logger.debug(f"Pressing hotkey: {'+'.join(keys)}")
        pyautogui.hotkey(*keys)
        return True

    async def _execute_write(self, action: Dict[str, Any]) -> bool:
        """Type text using keyboard."""
        text = action.get("text", "")
        if not text:
            logger.warning("Write action missing text")
            return False

        interval = action.get("interval", 0.05)
        logger.debug(f"Typing text: {text[:50]}{'...' if len(text) > 50 else ''}")
        pyautogui.write(text, interval=interval)
        return True

    async def _execute_press(self, action: Dict[str, Any]) -> bool:
        """Press a single key."""
        key = action.get("key")
        if not key:
            logger.warning("Press action missing key")
            return False

        presses = action.get("presses", 1)
        interval = action.get("interval", 0.1)
        logger.debug(f"Pressing key: {key} ({presses}x)")
        pyautogui.press(key, presses=presses, interval=interval)
        return True

    async def _execute_click(self, action: Dict[str, Any]) -> bool:
        """Click at a position."""
        x = action.get("x")
        y = action.get("y")
        button = action.get("button", "left")
        clicks = action.get("clicks", 1)

        if x is not None and y is not None:
            logger.debug(f"Clicking at ({x}, {y}) with {button} button")
            pyautogui.click(x, y, clicks=clicks, button=button)
        else:
            logger.debug(f"Clicking at current position with {button} button")
            pyautogui.click(clicks=clicks, button=button)
        return True

    async def _execute_sleep(self, action: Dict[str, Any]) -> bool:
        """Wait for a specified duration."""
        seconds = action.get("seconds", 1.0)
        logger.debug(f"Sleeping for {seconds} seconds")
        await asyncio.sleep(seconds)
        return True

    async def _execute_select_text(self, action: Dict[str, Any]) -> bool:
        """Select text using Shift+arrow keys."""
        chars = action.get("chars", 0)
        direction = action.get("direction", "left")

        if chars <= 0:
            logger.warning("Select text action missing chars count")
            return False

        key = "left" if direction == "left" else "right"
        logger.debug(f"Selecting {chars} characters to the {direction}")

        for _ in range(chars):
            pyautogui.hotkey("shift", key)
            await asyncio.sleep(0.02)

        return True

    async def _execute_move_to(self, action: Dict[str, Any]) -> bool:
        """Move mouse to a position."""
        x = action.get("x")
        y = action.get("y")
        duration = action.get("duration", 0.25)

        if x is None or y is None:
            logger.warning("MoveTo action missing x or y")
            return False

        logger.debug(f"Moving mouse to ({x}, {y})")
        pyautogui.moveTo(x, y, duration=duration)
        return True

    async def _execute_scroll(self, action: Dict[str, Any]) -> bool:
        """Scroll the mouse wheel."""
        clicks = action.get("clicks", 3)
        x = action.get("x")
        y = action.get("y")

        logger.debug(f"Scrolling {clicks} clicks")
        pyautogui.scroll(clicks, x, y)
        return True

    async def execute_subtasks(
        self,
        subtasks: List,
        on_progress: Optional[callable] = None
    ) -> bool:
        """
        Execute all subtasks in order.

        Args:
            subtasks: List of Subtask objects from TaskDecomposer
            on_progress: Optional callback function(subtask_index, total, description)

        Returns:
            True if all subtasks executed successfully
        """
        total = len(subtasks)
        logger.info(f"Executing {total} subtasks...")

        for i, subtask in enumerate(subtasks):
            # Report progress
            if on_progress:
                on_progress(i, total, subtask.description)

            print(f"  [{i+1}/{total}] {subtask.description}")

            # Get action from subtask context
            action = subtask.context.get("pyautogui_action")
            if action:
                success = await self.execute_action(action)
                if not success:
                    logger.error(f"Failed to execute: {subtask.description}")
                    return False

            # Wait after action
            wait_time = subtask.context.get("wait_after", 0.2)
            if wait_time > 0:
                await asyncio.sleep(wait_time)

        logger.info("All subtasks executed successfully!")
        return True


async def demo():
    """Demo function to test ActionExecutor."""
    from core.task_decomposer import Subtask

    # Create sample subtasks manually (simulating LLM output)
    subtasks = [
        Subtask.create(
            description="Open Run dialog",
            approach="keyboard",
            context={
                "pyautogui_action": {"type": "hotkey", "keys": ["win", "r"]},
                "wait_after": 0.5
            }
        ),
        Subtask.create(
            description="Type notepad",
            approach="keyboard",
            context={
                "pyautogui_action": {"type": "write", "text": "notepad", "interval": 0.05},
                "wait_after": 0.2
            }
        ),
        Subtask.create(
            description="Press Enter to launch",
            approach="keyboard",
            context={
                "pyautogui_action": {"type": "press", "key": "enter"},
                "wait_after": 2.0
            }
        ),
        Subtask.create(
            description="Type Hello World",
            approach="keyboard",
            context={
                "pyautogui_action": {"type": "write", "text": "Hello World from ActionExecutor!", "interval": 0.03},
                "wait_after": 0.2
            }
        ),
    ]

    print("\n" + "=" * 60)
    print("ActionExecutor Demo")
    print("=" * 60)
    print("\nThis will execute the following actions:")
    for i, st in enumerate(subtasks):
        print(f"  {i+1}. {st.description}")
        print(f"      Action: {st.context.get('pyautogui_action')}")

    print("\nStarting in 3 seconds... (move mouse to corner to abort)")
    for i in range(3, 0, -1):
        print(f"  {i}...")
        await asyncio.sleep(1)

    executor = ActionExecutor()
    success = await executor.execute_subtasks(subtasks)

    print(f"\nResult: {'SUCCESS' if success else 'FAILED'}")


if __name__ == "__main__":
    asyncio.run(demo())
